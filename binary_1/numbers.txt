1. Расположение многобайтовых значений в памяти компьютера

Допустим работа с памятью осуществляется побайтово, и мы хотим сохранить в
памяти (или прочитать из памяти) некоторое значение длинной в несколько байт,
как понять где находятся наиболее значимые байты, а где наименее значимые?

Этимология (Путешествие Гулливера)

1.1 Little-Endian

Наименее значимые байты располагаются по меньшим адресам в памяти. Такой способ
представления используется например в архитектуре x86 (да и вообще во многих
популярных архитектурах он используется по-умолчанию, например, ARM может
работать как с Little-Endian так и с Big-Endian, но как правило используют
первый вариант)

Пример: число 0xAA55 (старший байт - 0xAA, а младший байт - 0x55), мы хотим
сохранить его в память компьютера начиная с адреса A, тогда располагаться в
памяти число будет следующим образом:

    A A + 1
   55    AA

1.2 Big-Endian

Наиболее значимые байты располагаются по меньшим адресам в памяти. Такой способ
представления используется например в сетевых протоколах (наиболее значимые
байты полей заголовков стека TCP/IP идут раньше), кроме того некоторые
архитектуры могут работать с Big-Endian.

Пример: опять число 0xAA55, мы хотим его сохранить в памяти начиная с адреса A,
тогда располагаться в памяти число будет следующим образом:

    A A + 1
   AA    55

2. Представление целых чисел в двоичном формате

Представление беззнаковых целых чисел довольно очевидно, поэтому мы не будем
особо на нем останавливаться, за исключением разве BCD представления. Большая
часть материала дальше о том, как представлять знаковые числа.

2.1 Маргинальные представления

2.1.1 BCD (Binary Coded Decimals)

В таком представлении под каждый десятичный разряд отводится по 4/8 бит, т. е.
каждые 4 бита числа кодируют десятичную цифру. Такой формат представления целых
чисел поддерживается, в какой-то степени, архитектурой x86.

Например, мы хотим представить число 42, цифра 4 в двоичной системе счисления
представляется как 0100, а цифра 2 в двоичной системе счисления представляется
как 0010, собираем все вместе и получаем 01000010.

Представление отрицательных чисел в таком виде довольно проблематично. Поэтому
не будем его рассматривать.

2.1.2 Дополнение до единиц

В этом представлении все двоичные разряды кроме старшего имеют вес 2^i, где i -
номер разряда начиная с 0 для младших разрядов числа. А старший разряд числа
имеет отрицательный вес -2^(n - 1) + 1, где n - количество бит в числе (так как
считаем начиная с 0 то степень n - 1).

Т. е. если у нас есть n двоичных разрядов от самого младшего x(0) до самого
старшего x(n-1), то если мы будем интерпретировать эти разряды как n-битное
число представленное в дополнении до единиц, его значение можно будет посчитать
по формуле:

-x(n - 1) * (2^(n - 1) - 1) + sum(x(i) * 2^i for i in range(n - 1))

У этого представления есть одна особенность - число 0 можно представить двумя
способами. Если мы будем интерпретировать старший бит, как бит знака (а для
всех чисел кроме нуля это будет работать), то у нас как бы получается
отрицательный и положительный нули - это может создавать некоторые неудобства.

2.1.3 Знаковый старший бит

В дополнении до единиц старший бит естественным образом показывал знак числа,
но мы можем явно использовать старший бит как знак числа и использовать
следующий способ получения десятичного числа по битовому представлению:

-1^x(n - 1) * sum(x(i) * 2^i for i in range(n - 1))

2.1.4 Смещенное представление

Давайте зададим некоторое значение Bias, тогда мы можем использовать его для
представления знаковых чисел следующим образом:

sum(x(i) * 2^i for i in range(n)) - Bias

Т. е. все числа меньшие Bias, если интерпретировать их как беззнаковые при
вычитании преобразуются в знаковые числа. Например, будем работать с 8
разрядными числами и использовать Bias равный 127, тогда например, -1 будет
представляться как беззнаковое число 126, т. е. 01111110, а например 1 будет
представляться как беззнаковое число 128, т. е. 10000000.

2.2 Дополнение до двойки

Дополнение до двойки - самый распространенный способ двоичного представления
знаковых чисел, который реально используется в современных (и не очень)
процессорах. Дополнение до двойки похоже на дополнение до единиц, с той лишь
разницей, что старший разряд имеет другой вес, а именно -2^(n - 1). Т. е. чтобы
получит десятичное число по двоичному представлению нужно использовать формулу:

-x(n - 1) * 2^(n - 1) + sum(x(i) * 2^i for i in range(n - 1))

Этот формат примечателен тем, что в отличие от дополнения до единиц в нем 0
представим одним единственным образом. Кроме того, что и стало причиной его
популярности, для выполнения арифметических операций над числами в таком
формате можно использовать те же алгоритмы (и их аппаратные реализации), что и
для беззнаковых двоичных чисел.

Например, 8-битное число -1 представляется с использованием дополнения до двойки
следующим образом: 11111111, а 8-битное число 1 представляется как 00000001.
Если мы сложим эти двоичные числа по обычным правилам, то с учетом ограниченной
разрядности получим 00000000, что сходится с ожиданиями.

И так почти для всех чисел, исключением является наименьшее число. Например, для
8-битных чисел наименьшее представимое в дополнении до двойки число - это -128,
его двоичное представление 10000000. Не трудно заметить, что представить число
128 с использованием дополнения до двойки не получится. А число -128 получается
обратным самому себе, т. е. -128 + (-128) = 0.

Не трудно заметить, что старший бит в дополнении до двойки так же может
интерпретироваться как бит знака.

2.3 Преобразования типов

Когда в языках C или C++ вы преобразуете один целый тип к другому целому типу,
то гарантируется, что если значение представимо в том типе, к которому вы
производите преобразование, то оно сохранится.

Для преобразования значения беззнакового типа в другое значение беззнакового
типа такое преобразование осуществляется обычным отбрасыванием старших бит или
прибавлением старших незначащих нулей (в зависимости от того преобразуете вы
значение из типа с больше разрядностью к типу с меньшей разрядностью или
наоборот).

Для знаковых типов такое преобразование работать не будет. Например, возбмем
8-битное число -128, которое в дополнении до двойки представляется как 10000000.
Мы хотим преобразовать его к 16-битному знаковому типу, если мы просто добавим
незначащих 0 в начало, то получим следующие биты 0000000010000000, а для
16-битного числа представленного с использованием дополнения до двойки это
число соответствует 128, а не -128. Поэтому для таких преобразований
используется операция знакового расширения, т. е. мы добавляем слева не нули, а
значения знакового разряда, т. е. в нашем случае 10000000 преобразуется в
1111111110000000, что уже соответствует -128 в 16-битном представлении.

3. Арифметика с плавающей точкой

До 80-х годов производители компьютеров изобретали свои способы и форматы
представления чисел с плавающей точкой, до тех пор пока в 1985 году не вышел
стандарт IEEE 754. Этот стандарт описал представление чисел с плавающей точкой
и различные способы манипуляции этими числами. Теперь почти все компьютерные
системы используют именно этот формат представления чисел с плавающей точкой.

3.1 Числа с фиксированной точкой

Перед тем как рассматривать представление чисел с плавающей точкой пару слов
о числах с фиксированной точкой. Бинарное представление чисел естественным
образом расширяется на числа с фиксированной точкой.

Пусть у нас есть n бит, отведем младшие m - 1 бит под дробные разряды, тогда
десятичное представление числа может быть легко получено следующим образом:

sum(x(i) * 2^(i - m) for i in range(n))

т. е. для младших разрядов мы будем просто использовать отрицательные степени
двойки, а в остальном работать с ними как с обычными целыми числами.

3.2 Числа с плавающей точкой

Очевидной проблемой с числами с фиксированной точкой является то, что таким
способом нельзя представлять большие числа. Представление чисел с плавающей
точкой использует другой подход, а именно числа представляются в следующем
формате:

-1^s * M * 2^E

где s называют знаком, M называют мантиссой, а E называют экспонентой. Таким
образом, битовое представление чисел с плавающей точкой разделено на три части:

1. один бит отведен под знак
2. k-бит представляют экспоненту E - целое знаковое число в форме со сдвигом
3. m-бит представляют мантиссу M - дробное число с фиксированной точкой

Типичными значениями k и m являются 8 и 23, соответственно, для 32-битных чисел,
и 11 и 52 для 64-битных чисел.

Со знаковым битом все просто, но мантисса и экспонента хранятся по особенному.
Начнем с мантиссы. Мантисса хранит либо число от 1 до 2 (не включительно),
либо число от 0 до 1 (не включительно).

Рассмотрим случай, когда мантисса хранит число от 1 до 2. Очевидно все числа
будут иметь 1 в целой части, значит хранить эту 1 нет никакого смысла, поэтому
все m бит отводятся под хранение значащих разрядов с отрицательной степенью, а
единица в целой части подразумевается.

Очевидно, что если мантисса хранит числа от 1 до 2, то мы никак не можем точно
представить 0. Поэтому возможен второй вариант, когда мантисса хранит число от
0 до 1. Для этого варианта справедливо все то же самое, что справедливо для
первого случая, но подразумевается не 1 а 0.

Первый вариант называется нормализованным, а второй денормализованным. Как
определять какой именно вариант используется в данный момент? Это определяется
по значению экспоненты. Если экспонента состоит из всех 0, то используется
денормализованный вариант. Если экспонента не состоит из всех 0 или всех 1,
то используется нормализованный вариант.

Как уже было отмечено, экспонента представляется как знаковое число со
смещением. Bias всегда равен 2^(k - 1) - 1, но для подсчета значения экспоненты
используются разные формулы в нормализованном и денормализованном
представлениях. В нормализованном представлении мы используем обычную формулу
для представления знаковых чисел со смещением:

sum(x(i) * 2^i for i in range(k)) - Bias

Т. е. для обычных 32-битных чисел с плавающей точкой (k = 8) получаем 127, а
для 64-битных чисел с плавающей точкой (k = 11) получаем 1023. А диапазоны
значений экспоненты получаются от -126 до 127 и от -1022 до 1023.

Почему верхние границы не 128 и 1024? Потому что, как уже было отмечено, если
биты экспоненты состоят из всех единиц, то это особая ситуация, о которой мы
еще поговорим дальше.

Для денормализованных чисел, т. е. когда все биты хранящие экспоненту равны 0
значение экспоненты считается немного по другому:

1 - Bias

Так сделано, чтобы переход в значениях между нормализованными и
денормализованными числами был менее резким, т. е. чтобы разрыв был меньше.

Таким образом денормализованные числа служат для представления нуля (или
нулей, потому что очевидно есть положительный и отрицательный нули), а кроме
того с их помощью представляются числа близкие к нулю.

Как уже отмечалось, если биты экспоненты состоят из одних 1, то это особая
ситуация, и такое представление нужно интерпретировать особенным образом. Тут
есть несколько случаев:

1. все биты мантиссы нулевые, тогда число представляет бесконечность
(положительную или отрицательную в зависимости от бита знака)
2. если не все биты нулевые, тогда это представление соответствует специальному
значению NaN или "Not a Number". Такие значения возвращаются как результаты
операций, которые не могут быть представлены как вещественное число или
бесконечность.


Рассмотрим несколько примеров. Пусть у нас есть 8-битное число с плавающей
точкой, причем k = 4, а m = 3. Как представить 0? Тут все просто:

0 0000 000

так как все биты экспоненты равны 0, то это денормализованное число, т. е.
значение экспоненты нужно считать по формуле 1 - Bias. Bias равен 2^3 - 1, т. е.
7, а значение экспоненты соответсвенно -6. Так как это число денормализованное,
то в мантиссе подразуемваемый разряд 0, а собирая все вместе получаем:

(-1) ^ 0 * 0 * 2 ^ (-6) = 0

Теперь найдем в этом представлении наименьшее положительное число. Очевидно,
мы ищем денормализованное число, так как именно они дают нам наименьшие по
модулю числа. Значит экспонента должна состоять из всех 0, а само значение
экспоненты равно 1 - Bias = -6. Мантисса должна содержать единицу в самом младшем
разряде, а знаковый бит должен быть нулевым, так как нам нужно положительное
число, собираем все вместе:

0 0000 001 = (-1)^0 * 0.001 * 2^(-6) = 2^(-9) = 1/512

Теперь попробуем найти наибольшее денормализованное число. Логика действий та
же что и в прошлый раз, но теперь мантисса должна быть максимальной из возможных,
т. е. получаем:

0 0000 111 = (-1)^0 * 0.111 * 2^(-6) = (1/2 + 1/4 + 1/8) * 2^(-6) = 7/512

Если мы хотим найти наименьшее нормализованное число, то в битах экспоненты
должна быть хотя бы одна единица, и, очевидно, она должна быть в наименее
значащем разряде, т. е. биты экспоненты: 0001, что соответствует экспоненте равной
-6 (по формуле). Как мы видим две формулы для подсчета экспоненты очень хорошо
согласуются друг с другом при переходе от нормализованных чисел к
денормализованным. А минимальное значение мантиссы соответствует всем 0. Но в
нормализованном представлении у мантиссы подразумевается целая часть равная 1.
Собираем все вместе:

0 0001 000 = (-1)^0 * 1.000 * 2^(-6) = 1/64

Наконец наибольшее нормализованное число. Тут все просто, биты экспоненты должны
содержать ровно 1 ноль в наименее значащем разряде, т. е. получаем 1110. Биты
мантиссы все должны быть 1, т. е. 111. Собираем все вместе:

0 1110 111 = (-1)^0 * 1.111 * 2^(14 - 7) = (1 + 1/2 + 1/4 + 1/8) * 2^7 =
  = 15 * 16 = 240

3.3 Округление чисел с плавающей точкой

Числа с плавающей точкой только примерно представляют реальные вещественные
числа. Поэтому нужно иметь способ находить ближайшее к заданному число, которое
представимо в таком формате.

Стандарт IEEE определяет 4 различных способ округления чисел с плавающей точкой:

1. Round to even
2. Round toward zero
3. Round down
4. Round up

С последними 3-мя все понятно, но по умолчанию обычно используется первый
способ (если в стандартной библиотеке вашего языка не сказано обратное). Почему
же предпочтение отдается четным числам при округлении? Дело в том, что при
использовании обычной конвенции, когда числа с дробной частью >= 0.5 округляются
вверх, такое округление может вносить смещение в аггрегативные функции,
например, если нам нужно посчитать среднее значение набора чисел, то округление
чисел с дробной частью 0.5 вверх может дать в результате среднее значение чуть
больше реального значения. А округляя для половины чисел вверх, а для половины
вниз мы можем немного скомпенсировать такие эффекты.

Естественно округлять мы можем не только до целых. В реальности стандарт
определяет все арифметические операции с использованием округления до ближайшего
представимого числа.

3.4 Арифметические свойства чисел с плавающей точкой.

В отличие от обычных действий над вещественными числами, операции над числами
с плавающей точкой не обладают ассоциативностью (хотя обладают коммутативностью)

Например, результатом выражения (3.14+1e20) - 1e20 будет 0, потому что 3.14
потеряется из-за округления, а вот результат операции 3.14 + (1e20 - 1e20)
будет 3.14.

Отсутствие ассоциативности влечет за собой довольно серьезные последствия. Даже
самый простые задачи, как посчитать сумму набора чисел могут превратиться в
головную боль. Например, самый очевидный способ сделать это - отсортировать все
числа по возрастанию и суммировать начиная с наименьших. Менее очевидный способ
займет O(n) операций и известен как компенсирующее суммирование или алгоритм
Кэхена. Кстати, этот самый Кэхен и является одним из разработчиков стандарта.
